# JARVIS.PY-
'''Here is a description you can use for your GitHub repository. It's written to be clear, engaging, and highlight the key features of your project.

🤖 Jarvis: A Python-Powered Desktop Assistant
Jarvis is a versatile and intelligent desktop assistant built with Python. Inspired by the AI from the Iron Man movies, Jarvis can perform a wide range of tasks using a combination of voice commands and text input. It leverages powerful APIs for general knowledge, web searches, news, and weather, while also interacting with your local system to launch applications and manage files.

This project is a great example of how to integrate various Python libraries and external APIs to create a functional and interactive application.Dependencies:-
GEMINI_API_KEY
GOOGLE_CUSTOM_SEARCH_API_KEY
GOOGLE_CUSTOM_SEARCH_ENGINE_ID
OPENWEATHER_API_KEY
NEWS_API_KEY  
OPENCAGE_API_KEY'''

#MAIN CODE

import pyttsx3
import time
import speech_recognition as sr
import webbrowser
import re
import json
import platform
import os
import psutil
from datetime import datetime
import socket
import uuid
import subprocess
import requests
import pytz
import shutil
import google.generativeai as genai
from timezonefinder import TimezoneFinder
# --- 1. Configuration & API Keys ---
engine = pyttsx3.init()
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY") or "PASTE HERE GEMINI API KEY"
genai.configure(api_key=GEMINI_API_KEY)
GEMINI_MODEL_NAME = 'models/gemini-2.0-flash'
gemini_model = genai.GenerativeModel(GEMINI_MODEL_NAME)
GOOGLE_CUSTOM_SEARCH_API_KEY = "PASTE HERE GOOGLE CUSTOM SEARCH API KEY"
GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "PASTE HERE GOOGLE CUSTOM SEARCH ENGINE ID"
OPENWEATHER_API_KEY = "PASTE HERE OPEN WEATHER API KEY"
NEWS_API_KEY = "PASTE HERE NEWS API KEY"
OPENCAGE_API_KEY = "PASTE HERE OPEN CAGE API KEY"
FOLDERS_TO_BACKUP = [
    os.path.expanduser("~/Desktop"),
    os.path.expanduser("~/Documents"),
    os.path.expanduser("~/Downloads")
]
# --- 2. Initialization of Core Components ---
recognizer = sr.Recognizer()
tf = TimezoneFinder()
# --- 3. Helper Functions (Speech & Voice Setup) ---
def speak(text):
    """Speaks the given text using the initialized text-to-speech engine."""
    print(f"Speaking: {text}")
    engine.say(text)
    engine.runAndWait()
def listen():
    """Listens for user's voice input and returns the recognized text in lowercase."""
    try:
        with sr.Microphone() as source:
            print("Listening...")
            recognizer.adjust_for_ambient_noise(source)
            audio = recognizer.listen(source)
            print("Processing...")
            query = recognizer.recognize_google(audio)
            print(f"Recognized: {query}")
            return query.lower()
    except sr.UnknownValueError:
        print("Sorry, I did not understand that.")
        speak("Sorry, I did not understand that.")
        return None
    except sr.RequestError as e:
        print(f"Could not request results from Google Speech Recognition service; {e}")
        speak(f"Could not request results from the speech service; {e}")
        return None
def set_jarvis_voice():
    """Configures the text-to-speech engine to use a male voice and sets speech rate/volume."""
    voices = engine.getProperty('voices')
    for voice in voices:
        if "male" in voice.name.lower():
            engine.setProperty('voice', voice.id)
            break
    engine.setProperty('rate', 150)
    engine.setProperty('volume', 1.0)
# --- 4. AI & Search Functions ---
def generate_text_with_gemini(prompt):
    """Generates text using the Gemini 2.0 Flash model based on the given prompt."""
    try:
        response = gemini_model.generate_content(prompt)
        return response.text
    except Exception as e:
        return f"An error occurred with Gemini: {e}"
def google_search(query, num_results=1):
    """
    Fetches search results from Google Custom Search API and returns a formatted string
    containing the title, snippet, and link of the first result.
    """
    search_url = "https://www.googleapis.com/customsearch/v1"
    params = {
        "q": query,
        "key": GOOGLE_CUSTOM_SEARCH_API_KEY,
        "cx": GOOGLE_CUSTOM_SEARCH_ENGINE_ID,
        "num": num_results
    }
    try:
        response = requests.get(search_url, params=params)
        response.raise_for_status()
        results = response.json()
        if "error" in results:
            return {"error": results['error'].get('message', 'Unknown Google Search API error')}
        if "items" in results and results["items"]:
            first_result = results["items"][0]
            title = first_result.get("title", "No Title")
            snippet = first_result.get("snippet", "No Description Available")
            link = first_result.get("link", "No Link")
            full_result = f"Title: {title}\nSnippet: {snippet}\nLink: {link}"
            return full_result
        else:
            return "No search results found."
    except requests.exceptions.RequestException as e:
        return f"Error fetching search results: {str(e)}"
    except json.JSONDecodeError:
        return "Error decoding JSON response from Google Search API."
# --- 5. System & Environment Functions ---
def get_all_drives():
    """Returns a list of all available drive letters on Windows (e.g., ['C:/', 'D:/'])."""
    drives = []
    for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
        if os.path.exists(f"{letter}:/"):
            drives.append(f"{letter}:/")
    return drives
def find_usb_drive():
    """
    Detects and returns the mountpoint of a removable USB drive.
    Returns None if no removable drive is found.
    """
    for partition in psutil.disk_partitions():
        if 'removable' in partition.opts:
            return partition.mountpoint
    return None
def get_system_info():
    """
    Retrieves and returns various system information in a JSON formatted string.
    Includes platform details, hostname, IP/MAC addresses, CPU, RAM, disk usage, and users.
    """
    try:
        info = {}
        info['platform'] = platform.system()
        info['platform-release'] = platform.release()
        info['platform-version'] = platform.version()
        info['architecture'] = platform.machine()
        info['hostname'] = socket.gethostname()
        info['ip-address'] = socket.gethostbyname(socket.gethostname())
        info['mac-address'] = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) for elements in range(5, -1, -1)])
        info['processor'] = platform.processor()
        info['ram'] = f"{round(psutil.virtual_memory().total / (1024.0 ** 3))} GB"
        info['boot_time'] = datetime.fromtimestamp(psutil.boot_time()).strftime("%Y-%m-%d %H:%M:%S")
        info['cpu_count_physical'] = psutil.cpu_count(logical=False)
        info['cpu_count_logical'] = psutil.cpu_count(logical=True)
        info['disk_usage_root_percent'] = psutil.disk_usage('/').percent
        info['users'] = [user.name for user in psutil.users()] if hasattr(psutil, 'users') else []
        return json.dumps(info, indent=4)
    except Exception as e:
        return f"Error gathering system info: {e}"
def get_current_location():
    """
    Retrieves the current public IP-based location (city, region, country)
    using the ipinfo.io API.
    """
    try:
        response = requests.get('https://ipinfo.io')
        response.raise_for_status()
        data = response.json()
        location = f"{data.get('city', 'Unknown City')}, {data.get('region', 'Unknown Region')}, {data.get('country', 'Unknown Country')}"
        speak(f"Your current location is: {location}")
        print(f"Your current location is: {location}")
        return location
    except requests.exceptions.RequestException as e:
        speak(f"Sorry, I couldn't retrieve your location. Error: {e}")
        print(f"Error fetching location: {e}")
        return None
    except json.JSONDecodeError:
        speak("Error decoding location data.")
        print("Error decoding location data.")
        return None
# --- 6. Weather & Time Functions ---
def get_weather(query):
    """
    Fetches and speaks the current weather information for a specified city
    using the OpenWeatherMap API.
    """
    try:
        city = query.replace("weather of", "").strip()
        if not city:
            speak("Please specify a valid city name for weather.")
            return
        url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={OPENWEATHER_API_KEY}&units=metric"
        response = requests.get(url)
        data = response.json()

        if data["cod"] != 200:
            speak(f"Sorry, I couldn't find weather information for {city}. {data.get('message', 'Please check the city name.')}")
            print(f"Weather API Error: {data.get('message', 'Unknown error for city.')}")
        else:
            weather_desc = data["weather"][0]["description"]
            temperature = data["main"]["temp"]
            speak(f"The weather in {city} is currently {weather_desc} with a temperature of {temperature} degrees Celsius.")
            print(f"Weather in {city}: {weather_desc}, Temperature: {temperature}°C")
    except requests.exceptions.RequestException as e:
        speak(f"An error occurred while fetching weather data: {e}")
        print(f"Error fetching weather: {e}")
    except json.JSONDecodeError:
        speak("Error decoding weather data.")
        print("Error decoding weather data.")
    except Exception as e:
        speak(f"An unexpected error occurred with weather: {e}")
        print(f"Unexpected error in get_weather: {e}")
def get_time_for_city(query):
    """
    Fetches and speaks the current time for a specified city by first geocoding
    the city to get its coordinates and then finding its timezone.
    """
    try:
        city = query.replace("what is the time of", "").strip().replace("what is the time in", "").strip()
        if not city:
            speak("Please specify a valid city name for time.")
            return
        if city.lower() == "kolkata":
            city_for_geocode = "Kolkata, India"
        elif city.lower() == "india":
            city_for_geocode = "New Delhi, India"
        else:
            city_for_geocode = city
        geocode_url = f"https://api.opencagedata.com/geocode/v1/json?q={city_for_geocode}&key={OPENCAGE_API_KEY}"
        response = requests.get(geocode_url)
        data = response.json()
        if data["results"]:
            lat = data["results"][0]["geometry"]["lat"]
            lon = data["results"][0]["geometry"]["lng"]
            print(f"Geocoded: {city_for_geocode} -> Lat: {lat}, Lon: {lon}")
            timezone_str = tf.timezone_at(lng=lon, lat=lat)
            if timezone_str is None:
                speak(f"Sorry, I couldn't find the timezone for {city_for_geocode}.")
                return
            local_timezone = pytz.timezone(timezone_str)
            local_time = datetime.now(local_timezone)
            time_string = local_time.strftime("%I:%M:%S %p")
            speak(f"The current time in {city} is {time_string}.")
            print(f"Time in {city}: {time_string} ({timezone_str})")
        else:
            speak(f"Sorry, I couldn't find geographical information for {city}. Please try again.")
            print(f"No geocoding results for {city_for_geocode}.")
    except requests.exceptions.RequestException as e:
        speak(f"An error occurred while fetching time information: {e}")
        print(f"Error fetching time/geocode: {e}")
    except json.JSONDecodeError:
        speak("Error decoding geocoding data.")
        print("Error decoding geocoding data.")
    except pytz.exceptions.UnknownTimeZoneError:
        speak(f"Could not determine a valid timezone for {city}.")
        print(f"Unknown timezone for {city}.")
    except Exception as e:
        speak(f"An unexpected error occurred with time lookup: {e}")
        print(f"Unexpected error in get_time_for_city: {e}")
# --- 7. News Function ---
def get_latest_news():
    """
    Fetches the top 5 latest news headlines and descriptions from NewsAPI
    for the US and speaks them out.
    """
    try:
        url = f"https://newsapi.org/v2/top-headlines?country=us&apiKey={NEWS_API_KEY}"
        response = requests.get(url)
        data = response.json()
        if data["status"] == "ok":
            articles = data["articles"]
            if articles:
                speak("Here are the latest news headlines:")
                for i, article in enumerate(articles[:5]):
                    title = article.get('title', 'No Title')
                    description = article.get('description', 'No Description')
                    speak(f"News {i+1}. Title: {title}. Description: {description}")
                    print(f"News {i+1}. Title: {title}\nDescription: {description}\n---")
            else:
                speak("Sorry, I couldn't fetch the latest news.")
        else:
            speak("Sorry, I couldn't fetch the news. Please try again later.")
            print(f"News API Error: {data.get('message', 'Unknown error.')}")
    except requests.exceptions.RequestException as e:
        speak(f"An error occurred while fetching the news: {e}")
        print(f"Error fetching news: {e}")
    except json.JSONDecodeError:
        speak("Error decoding news data.")
        print("Error decoding news data.")
    except Exception as e:
        speak(f"An unexpected error occurred with news: {e}")
        print(f"Unexpected error in get_latest_news: {e}")
# --- 8. File Operations & Backup ---
def backup_important_files():
    """
    Prompts the user to insert a USB drive, waits for it, and then copies
    predefined important folders (Desktop, Documents) to a 'Backup' folder
    on the detected USB drive.
    """
    speak("Please insert your USB drive. I will wait for it.")
    print("🔍 Waiting for USB drive...")
    while True:
        usb_path = find_usb_drive()
        if usb_path:
            speak(f"USB drive detected at {usb_path}. Starting backup process.")
            print(f"✅ USB detected at {usb_path}, starting backup...")
            try:
                backup_folder = os.path.join(usb_path, "JarvisBackup")
                os.makedirs(backup_folder, exist_ok=True)
                speak(f"Creating backup folder at {backup_folder}")

                for folder in FOLDERS_TO_BACKUP:
                    if os.path.exists(folder):
                        dest = os.path.join(backup_folder, os.path.basename(folder))
                        speak(f"Copying {os.path.basename(folder)} to backup.")
                        shutil.copytree(folder, dest, dirs_exist_ok=True)
                        print(f"Copied: {folder} to {dest}")
                    else:
                        print(f"Warning: Source folder not found - {folder}")
                        speak(f"Warning: {os.path.basename(folder)} folder not found, skipping.")
                speak("Backup completed successfully!")
                print("✅ Backup completed successfully!")
                break
            except Exception as e:
                speak(f"An error occurred during backup: {e}")
                print(f"Error during backup: {e}")
                break
        else:
            speak("USB drive not found. Still waiting...")
            time.sleep(5)
# --- 9. Application & Website Launching ---
def open_website(query):
    """Opens a website in the default web browser based on the query."""
    website_name = query.replace("open", "").strip()
    if not website_name:
        speak("Please specify which website to open.")
        return
    if not website_name.startswith("http"):
        if "." not in website_name:
            url = f"https://www.{website_name}.com"
        else:
            url = f"https://www.{website_name}"
    else:
        url = website_name
    speak(f"Opening {website_name} website.")
    try:
        webbrowser.open(url)
        print(f"Opened: {url}")
    except Exception as e:
        speak(f"Could not open {website_name}. Error: {e}")
        print(f"Error opening website {url}: {e}")
def open_application_or_file(query):
    """
    Attempts to open common applications based on keywords in the query.
    Uses os.startfile for Windows applications.
    """
    app_name = query.lower().strip()
    apps = {
        "google": "chrome.exe",
        "brave": "brave.exe",
        "calculator": "calc.exe",
        "notepad": "notepad.exe",
        "word": "WINWORD.EXE",
        "excel": "EXCEL.EXE",
        "powerpoint": "POWERPNT.EXE",
        "chrome": "chrome.exe",
        "firefox": "firefox.exe",
        "edge": "msedge.exe",
        "vlc": "vlc.exe",
        "explorer": "explorer.exe",
        "file explorer": "explorer.exe",
        "command prompt": "cmd.exe",
        "cmd": "cmd.exe",
        "task manager": "taskmgr.exe",
        "control panel": "control.exe",
        "paint": "mspaint.exe"
    }
    opened = False
    for keyword, exe_name in apps.items():
        if keyword in app_name:
            try:
                os.startfile(exe_name)
                speak(f"Opening {keyword}.")
                print(f"Opened: {exe_name}")
                opened = True
                break
            except FileNotFoundError:
                speak(f"Sorry, I couldn't find {keyword}.")
                print(f"Error: {exe_name} not found.")
            except Exception as e:
                speak(f"An error occurred while trying to open {keyword}: {e}")
                print(f"Error opening {exe_name}: {e}")
            break
    if not opened:
        speak("Sorry, I don't know how to open that application or file.")
        print('Application/File Not Found or Not Supported.')
def search_web_general(query):
    """Performs a general web search on Google for the given query."""
    search_term = query.replace("search", "").strip()
    if not search_term:
        speak("Please tell me what you want me to search for.")
        return
    speak(f"Searching for {search_term} on Google.")
    webbrowser.open(f"https://www.google.com/search?q={search_term}")
    print(f"Web search initiated for: {search_term}")
# --- 10. Main Command Processing Logic ---
def process_command(query):
    """
    Processes the user's voice or text command and calls the appropriate function.
    """
    query = query.lower()
    if query is None or query == "":
        print("Please type a valid command.")
        return
    elif "what is your name" in query:
        speak("I am Jarvis, at your service.")
    elif "what can you do" in query or "what you can do" in query:
        speak('I can provide information using my general knowledge, browse the web, launch applications, perform file system operations like backup, provide system information, tell you your location, give you time and weather updates, and retrieve the latest news headlines.')
        print('I can give information using my General Knowledge and can do work like Web Browsing, Application Launching, File System Operations, System Information, Location Services, Time and Weather, News Retrieval and User Interface.')
    elif "hello" in query or "hi jarvis" in query:
        speak("Hello there! How can I assist you?")
    elif "how are you" in query:
        speak("I am functioning optimally, thank you for asking!")
    elif "backup" in query or "copy files to usb" in query:
        backup_important_files()
    elif "location" in query or "where am i" in query:
        get_current_location()
    elif 'system info' in query:
        system_info = get_system_info()
        speak("Here is your system information:")
        print(system_info)
    elif "news" in query or "latest news" in query:
        get_latest_news()
    elif "open" in query and ("website" in query or "." in query):
        open_website(query)
    elif "open" in query:
        open_application_or_file(query)
    elif "weather of" in query:
        get_weather(query)
    elif "time of" in query or "what is the time in" in query:
        get_time_for_city(query)
    elif "search" in query and "google" not in query:
        search_web_general(query)
    elif "google search" in query or "search on google" in query:
        search_term = query.replace("google search", "").replace("search on google", "").strip()
        if search_term:
            result = google_search(search_term)
            speak("Here is what I found on Google:")
            speak(result)
            print("Google Search Result:\n", result)
        else:
            speak("What would you like me to search for on Google?")
            print("No search term provided for Google search.")
    else:
        speak("Let me check that for you.")
        gemini_output = generate_text_with_gemini(query)
        print("\nJarvis Output:")
        print(gemini_output)
        print("-" * 30)
# --- 11. Main Execution Loop ---
def run_jarvis():
    """Main function to run the Jarvis assistant."""
    set_jarvis_voice()
    speak("Hello, I am Jarvis, how can I assist you today?")
    while True:
        mode = input("Do you want to (1) Speak or (2) Type? (Type 'exit' to quit): ").strip().lower()
        query = None
        if mode == "1":
            query = listen()
        elif mode == "2":
            query = input("Type your query: ").strip()
        elif mode == "exit":
            speak("Goodbye!")
            print("Jarvis is stopping...")
            break
        else:
            speak("Invalid choice. Please enter 1 to speak, 2 to type, or 'exit' to quit.")
            continue
        if query:
            print(f"You said/typed: '{query}'")
            if query.lower() in ["stop", "quit", "exit"]:
                speak("Goodbye!")
                print("Jarvis is stopping...")
                break
            process_command(query)
if __name__ == "__main__":
    run_jarvis()

